// Grammar rules for Yul program.

// Yul source unit.
source_unit =  { SOI? ~ object ~ EOI? }

// Yul object.
object = {
    OBJECT ~
    string_literal ~
    OPEN_BRACKET ~
    code ~
    (object | data)* ~
    CLOSE_BRACKET
}

// Object code.
code = { CODE ~ block }

// Object data.
data = {
    DATA ~
    string_literal ~
    (hex_literal | string_literal)
}

// Code block.
block = { OPEN_BRACKET ~ (statement)* ~ CLOSE_BRACKET }

// Code statement.
statement = {
    block
  | function_definition
  | variable_declaration
  | if_statement
  | for_statement
  | switch_statement
  | break_statement
  | continue_statement
  | leave_statement
  | assign_statement
  | expression
}

// Function definition.
function_definition = {
    FUNCTION ~
    identifier ~
    OPEN_PAREN ~
    (typed_identifier_list)? ~
    CLOSE_PAREN ~
    (RETURN_SEPARATOR ~ typed_identifier_list)? ~
    block
}

// Variable declaration.
variable_declaration = { LET ~ typed_identifier_list ~ (COLON_EQUAL ~ expression)? }

// Assignment.
assign_statement = { identifier_list ~  COLON_EQUAL ~ expression }

// Expression.
expression = {
    function_call
  | member_expr
  | identifier
  | literal
}

// `if` statement.
if_statement = { IF ~ expression ~ block }

// `switch` statement.
switch_statement = {
    SWITCH ~
    expression ~
    (((switch_value)+ ~ (switch_default)?) | switch_default)
}

// Case-value of the switch statement
switch_value = { CASE ~ literal ~ block }

// Default case of the switch statement
switch_default = { DEFAULT ~ block }

// `for` statement.
for_statement = { FOR ~ block ~ expression ~ block ~ block }

// `break` statement.
break_statement = { BREAK }

// `continue` statement.
continue_statement = { CONTINUE }

// `leave` statement.
leave_statement = { LEAVE }

// Function call.
function_call = { identifier ~ "(" ~ (expression ~ ("," ~ expression)*)? ~ ")" }

// Member access expression.
member_expr = { identifier ~ DOT ~ identifier }

// Identifier
identifier = @ { (alpha | "_" | "$") ~ (alpha | digit | "_" | "$")* }
identifier_list = { identifier ~ ("," ~ identifier)* }

// Typed-identifier
typed_identifier = { identifier ~ (COLON ~ data_type)? }
typed_identifier_list = { typed_identifier ~ ("," ~ typed_identifier)* }

// Data Type
data_type = {
    bool_type
  | int_type
  | string_type
}

// Bool type
bool_type = { BOOL }

// Int type
int_type = { (INT | UINT) ~ bitwidth}
bitwidth = { ('1'..'9') ~ ('1'..'9')* }

// String type
string_type = { STRING }

// Literal
literal = {
    number_literal
  | string_literal
  | hex_literal
  | bool_literal
}

// Number literal.
number_literal = { hex_number | decimal_number }
hex_number = @ { "0x" ~ ('0'..'9' | 'a'..'f' | 'A'..'F')+ }
decimal_number = @ { digit+ }

// Boolean literal.
bool_literal = { TRUE | FALSE }

// Hex literal.
hex_literal = {
    HEX ~
    ("\"" ~ (('0'..'9' | 'a'..'f' | 'A'..'F'){2})* ~ "\""
      | "\'" ~ (('0'..'9' | 'a'..'f' | 'A'..'F'){2})* ~ "\'")
}

// String literal.
string_literal = { QUOTATION ~ string_value ~ QUOTATION }
string_value = {
    ((!("\\" | "\n" | "\r" | "\"") ~ ANY) | "\\" ~ (!( "\n" ) ~ ANY))*
}

// Character and digit
alpha = _ { 'a'..'z' | 'A'..'Z' }
digit = _ { '0'..'9' }

// Boolean
TRUE = { "true" }
FALSE = { "false" }

// Symbols for data type
BOOL = _ { "bool" }
STRING = _ { "string" }
INT = _ { "int" }
UINT = _ { "uint" }

// Symbols for Yul keywords
BREAK = _ { "break" }
CASE = _ { "case" }
CODE = _ { "code" }
CONTINUE = _ { "continue" }
DATA = _ { "data" }
DEFAULT = _ { "default" }
FOR = _ { "for" }
FUNCTION = _ { "function" }
IF = _ { "if" }
LEAVE = _ { "leave" }
LET = _ { "let" }
OBJECT = _ { "object" }
SWITCH = _ { "switch" }
HEX = _ { "hex"}

// Symbols, do not capture
COLON = _ { ":" }
COLON_EQUAL = _ { ":=" }
OPEN_PAREN = _ { "(" }
CLOSE_PAREN = _ { ")" }
OPEN_BRACKET = _ { "{" }
CLOSE_BRACKET = _ { "}" }
QUOTATION = _ { "\"" }
DOT = _ { "." }

// Captured symbols
RETURN_SEPARATOR = { "->" }                // for function returns

//-----------------------------------------
// Do not add new rules beyond this line.

// Special rules for whitespace (WHITESPACE is a reserved name of PEST)
WHITESPACE = _ { " " | "\t" | newline }
newline = _ { "\n" | "\r\n" | "\r" }

// Special rules for comments (COMMENT is a reserved name of PEST)
COMMENT = { (block_comment | line_comment) }          // Capture comment
block_comment = { "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
line_comment = { "//" ~ (!newline ~ ANY)* ~ newline }
